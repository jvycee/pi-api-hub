const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const logger = require('../shared/logger');

class BananaVulnerabilityScanner {
  constructor() {
    this.scanResults = new Map();
    this.vulnerabilityDatabase = new Map();
    this.lastScanTime = null;
    this.scanHistory = [];
    this.bananaSecurityLevel = 'VULNERABILITY_HUNTER';
    
    this.initializeBananaScanner();
    this.loadVulnerabilityDatabase();
    this.startPeriodicScanning();
  }

  initializeBananaScanner() {
    logger.info('üçåüîç BANANA VULNERABILITY SCANNER ACTIVATED üîçüçå', {
      service: 'banana-vulnerability-scanner',
      scannerType: 'COMPREHENSIVE',
      bananaLevel: 'SECURITY_HUNTER'
    });
  }

  // üçå Load vulnerability patterns database üçå
  loadVulnerabilityDatabase() {
    this.vulnerabilityDatabase.set('dependency_vulnerabilities', {
      patterns: ['known_vulnerable_packages'],
      severity: 'HIGH',
      description: 'Dependencies with known security vulnerabilities'
    });

    this.vulnerabilityDatabase.set('hardcoded_secrets', {
      patterns: [
        /(?:password|pwd|pass)\s*[:=]\s*['"][^'"]+['"]/gi,
        /(?:api[_-]?key|apikey)\s*[:=]\s*['"][^'"]+['"]/gi,
        /(?:secret|token)\s*[:=]\s*['"][^'"]+['"]/gi,
        /(?:private[_-]?key)\s*[:=]\s*['"][^'"]+['"]/gi
      ],
      severity: 'CRITICAL',
      description: 'Hardcoded secrets or credentials in source code'
    });

    this.vulnerabilityDatabase.set('sql_injection_vectors', {
      patterns: [
        /query\s*\+\s*['"][^'"]*['"]\s*\+/gi,
        /execute\s*\(\s*['"][^'"]*['"]\s*\+/gi,
        /exec\s*\(\s*['"][^'"]*['"]\s*\+/gi
      ],
      severity: 'HIGH',
      description: 'Potential SQL injection vulnerabilities'
    });

    this.vulnerabilityDatabase.set('xss_vectors', {
      patterns: [
        /innerHTML\s*=\s*[^;]+(?!sanitiz)/gi,
        /document\.write\s*\(\s*[^)]*\)/gi,
        /eval\s*\(\s*[^)]*\)/gi,
        /setTimeout\s*\(\s*['"][^'"]*['"]/gi
      ],
      severity: 'MEDIUM',
      description: 'Potential XSS vulnerabilities'
    });

    this.vulnerabilityDatabase.set('insecure_randomness', {
      patterns: [
        /Math\.random\s*\(\s*\)/gi,
        /new\s+Date\s*\(\s*\)\.getTime\s*\(\s*\)/gi
      ],
      severity: 'MEDIUM',
      description: 'Use of insecure randomness for security purposes'
    });

    this.vulnerabilityDatabase.set('path_traversal', {
      patterns: [
        /fs\.readFile\s*\(\s*[^,)]*req\./gi,
        /fs\.writeFile\s*\(\s*[^,)]*req\./gi,
        /path\.join\s*\(\s*[^,)]*req\./gi
      ],
      severity: 'HIGH',
      description: 'Potential path traversal vulnerabilities'
    });

    this.vulnerabilityDatabase.set('command_injection', {
      patterns: [
        /exec\s*\(\s*[^,)]*req\./gi,
        /spawn\s*\(\s*[^,)]*req\./gi,
        /execSync\s*\(\s*[^,)]*req\./gi
      ],
      severity: 'CRITICAL',
      description: 'Potential command injection vulnerabilities'
    });

    this.vulnerabilityDatabase.set('weak_crypto', {
      patterns: [
        /createHash\s*\(\s*['"]md5['"]/gi,
        /createHash\s*\(\s*['"]sha1['"]/gi,
        /Math\.random\s*\(\s*\)\s*\*\s*\d+/gi
      ],
      severity: 'MEDIUM',
      description: 'Use of weak cryptographic algorithms'
    });

    logger.info('üçå VULNERABILITY DATABASE LOADED', {
      totalPatterns: this.vulnerabilityDatabase.size,
      bananaDatabase: 'COMPREHENSIVE'
    });
  }

  // üçå Comprehensive security scan üçå
  async performComprehensiveScan() {
    const scanId = `scan_${Date.now()}`;
    const startTime = Date.now();

    logger.info('üçåüîç STARTING COMPREHENSIVE BANANA SECURITY SCAN üîçüçå', {
      scanId,
      timestamp: new Date().toISOString()
    });

    try {
      const scanResults = {
        scanId,
        timestamp: new Date().toISOString(),
        duration: null,
        results: {
          codeVulnerabilities: await this.scanSourceCode(),
          dependencyVulnerabilities: await this.scanDependencies(),
          configurationIssues: await this.scanConfiguration(),
          filePermissions: await this.scanFilePermissions(),
          environmentSecurity: await this.scanEnvironmentSecurity(),
          networkSecurity: await this.scanNetworkConfiguration()
        },
        summary: null,
        bananaSecurityScore: null
      };

      // Generate summary
      scanResults.summary = this.generateScanSummary(scanResults.results);
      scanResults.bananaSecurityScore = this.calculateBananaSecurityScore(scanResults.results);
      scanResults.duration = Date.now() - startTime;

      // Store results
      this.scanResults.set(scanId, scanResults);
      this.lastScanTime = Date.now();
      this.scanHistory.unshift({
        scanId,
        timestamp: scanResults.timestamp,
        score: scanResults.bananaSecurityScore,
        criticalIssues: scanResults.summary.critical,
        highIssues: scanResults.summary.high
      });

      // Keep only last 10 scans
      if (this.scanHistory.length > 10) {
        this.scanHistory = this.scanHistory.slice(0, 10);
      }

      logger.info('üçå COMPREHENSIVE SCAN COMPLETED', {
        scanId,
        duration: scanResults.duration,
        bananaSecurityScore: scanResults.bananaSecurityScore,
        totalIssues: scanResults.summary.total
      });

      return scanResults;

    } catch (error) {
      logger.error('üö® BANANA SECURITY SCAN FAILED', {
        scanId,
        error: error.message
      });
      throw error;
    }
  }

  // Scan source code for vulnerabilities
  async scanSourceCode() {
    const vulnerabilities = [];
    const codebaseRoot = process.cwd();

    try {
      const jsFiles = this.findJavaScriptFiles(codebaseRoot);
      
      for (const filePath of jsFiles) {
        try {
          const content = fs.readFileSync(filePath, 'utf8');
          const fileVulns = this.analyzeCodeContent(filePath, content);
          vulnerabilities.push(...fileVulns);
        } catch (error) {
          logger.warn('Failed to scan file', { filePath, error: error.message });
        }
      }

      return {
        filesScanned: jsFiles.length,
        vulnerabilities,
        byType: this.groupVulnerabilitiesByType(vulnerabilities),
        bySeverity: this.groupVulnerabilitiesBySeverity(vulnerabilities)
      };

    } catch (error) {
      logger.error('Source code scan failed', { error: error.message });
      return { error: error.message, vulnerabilities: [] };
    }
  }

  // Find JavaScript files to scan
  findJavaScriptFiles(dir, files = []) {
    try {
      const items = fs.readdirSync(dir);
      
      for (const item of items) {
        const fullPath = path.join(dir, item);
        const stat = fs.statSync(fullPath);
        
        if (stat.isDirectory()) {
          // Skip node_modules and other unnecessary directories
          if (!['node_modules', '.git', 'logs', 'backups', 'coverage'].includes(item)) {
            this.findJavaScriptFiles(fullPath, files);
          }
        } else if (item.endsWith('.js') && !item.includes('.test.') && !item.includes('.spec.')) {
          files.push(fullPath);
        }
      }
    } catch (error) {
      // Ignore permission errors
    }
    
    return files;
  }

  // Analyze code content for vulnerabilities
  analyzeCodeContent(filePath, content) {
    const vulnerabilities = [];
    const lines = content.split('\n');

    for (const [vulnType, vulnData] of this.vulnerabilityDatabase.entries()) {
      if (vulnData.patterns) {
        for (const pattern of vulnData.patterns) {
          let match;
          const regex = new RegExp(pattern.source, pattern.flags || 'gi');
          
          while ((match = regex.exec(content)) !== null) {
            const lineNumber = content.substring(0, match.index).split('\n').length;
            
            vulnerabilities.push({
              type: vulnType,
              severity: vulnData.severity,
              description: vulnData.description,
              file: path.relative(process.cwd(), filePath),
              line: lineNumber,
              code: lines[lineNumber - 1]?.trim(),
              match: match[0],
              bananaRisk: this.calculateBananaRisk(vulnData.severity)
            });
          }
        }
      }
    }

    return vulnerabilities;
  }

  // Scan dependencies for vulnerabilities
  async scanDependencies() {
    try {
      const packageJsonPath = path.join(process.cwd(), 'package.json');
      
      if (!fs.existsSync(packageJsonPath)) {
        return { error: 'package.json not found' };
      }

      // Run npm audit
      let auditResult;
      try {
        const auditOutput = execSync('npm audit --json', { 
          encoding: 'utf8',
          timeout: 30000 
        });
        auditResult = JSON.parse(auditOutput);
      } catch (error) {
        // npm audit returns non-zero exit code when vulnerabilities found
        if (error.stdout) {
          try {
            auditResult = JSON.parse(error.stdout);
          } catch {
            return { error: 'Failed to parse npm audit output' };
          }
        } else {
          return { error: 'npm audit failed', details: error.message };
        }
      }

      const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
      
      return {
        totalDependencies: Object.keys(packageJson.dependencies || {}).length + 
                          Object.keys(packageJson.devDependencies || {}).length,
        vulnerabilities: auditResult.vulnerabilities || {},
        metadata: auditResult.metadata || {},
        advisories: auditResult.advisories || {},
        bananaStatus: this.getVulnerabilityStatus(auditResult.metadata)
      };

    } catch (error) {
      logger.error('Dependency scan failed', { error: error.message });
      return { error: error.message };
    }
  }

  // Scan configuration for security issues
  async scanConfiguration() {
    const issues = [];

    try {
      // Check .env file
      const envPath = path.join(process.cwd(), '.env');
      if (fs.existsSync(envPath)) {
        const envContent = fs.readFileSync(envPath, 'utf8');
        const envIssues = this.analyzeEnvironmentFile(envContent);
        issues.push(...envIssues);
      }

      // Check package.json security settings
      const packageJsonPath = path.join(process.cwd(), 'package.json');
      if (fs.existsSync(packageJsonPath)) {
        const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
        const packageIssues = this.analyzePackageJson(packageJson);
        issues.push(...packageIssues);
      }

      // Check for sensitive files
      const sensitiveFiles = this.findSensitiveFiles(process.cwd());
      issues.push(...sensitiveFiles);

      return {
        totalIssues: issues.length,
        issues,
        bySeverity: this.groupVulnerabilitiesBySeverity(issues),
        bananaConfigScore: this.calculateConfigScore(issues)
      };

    } catch (error) {
      logger.error('Configuration scan failed', { error: error.message });
      return { error: error.message, issues: [] };
    }
  }

  // Analyze environment file
  analyzeEnvironmentFile(content) {
    const issues = [];
    const lines = content.split('\n');

    lines.forEach((line, index) => {
      const lineNumber = index + 1;
      
      // Check for exposed secrets
      if (line.includes('API_KEY') && !line.includes('your_') && !line.includes('example')) {
        issues.push({
          type: 'exposed_api_key',
          severity: 'CRITICAL',
          description: 'API key potentially exposed in environment file',
          file: '.env',
          line: lineNumber,
          bananaRisk: 'MAXIMUM'
        });
      }

      // Check for weak passwords
      if (line.includes('PASSWORD') && line.length < 20) {
        issues.push({
          type: 'weak_password',
          severity: 'MEDIUM',
          description: 'Potentially weak password in environment file',
          file: '.env',
          line: lineNumber,
          bananaRisk: 'MEDIUM'
        });
      }
    });

    return issues;
  }

  // Analyze package.json for security issues
  analyzePackageJson(packageJson) {
    const issues = [];

    // Check for development dependencies in production
    if (packageJson.devDependencies && Object.keys(packageJson.devDependencies).length > 0) {
      issues.push({
        type: 'dev_dependencies',
        severity: 'LOW',
        description: 'Development dependencies present (ensure they are not installed in production)',
        file: 'package.json',
        bananaRisk: 'LOW'
      });
    }

    // Check for missing security-related scripts
    const scripts = packageJson.scripts || {};
    if (!scripts['security-check'] && !scripts['audit']) {
      issues.push({
        type: 'missing_security_scripts',
        severity: 'MEDIUM',
        description: 'No security check scripts configured',
        file: 'package.json',
        bananaRisk: 'MEDIUM'
      });
    }

    return issues;
  }

  // Find sensitive files
  findSensitiveFiles(dir) {
    const sensitiveFiles = [];
    const sensitivePatterns = [
      /\.pem$/,
      /\.key$/,
      /\.p12$/,
      /\.pfx$/,
      /id_rsa$/,
      /id_dsa$/,
      /\.env\.production$/,
      /\.env\.local$/
    ];

    try {
      const files = fs.readdirSync(dir);
      
      for (const file of files) {
        const filePath = path.join(dir, file);
        const stat = fs.statSync(filePath);
        
        if (stat.isFile()) {
          const isSensitive = sensitivePatterns.some(pattern => pattern.test(file));
          if (isSensitive) {
            sensitiveFiles.push({
              type: 'sensitive_file',
              severity: 'HIGH',
              description: `Sensitive file found: ${file}`,
              file: file,
              bananaRisk: 'HIGH'
            });
          }
        }
      }
    } catch (error) {
      // Ignore permission errors
    }

    return sensitiveFiles;
  }

  // Scan file permissions
  async scanFilePermissions() {
    const issues = [];

    try {
      // Check .env file permissions
      const envPath = path.join(process.cwd(), '.env');
      if (fs.existsSync(envPath)) {
        const stat = fs.statSync(envPath);
        const mode = stat.mode & parseInt('777', 8);
        
        if (mode !== parseInt('600', 8) && mode !== parseInt('644', 8)) {
          issues.push({
            type: 'file_permissions',
            severity: 'MEDIUM',
            description: `.env file has potentially insecure permissions: ${mode.toString(8)}`,
            file: '.env',
            bananaRisk: 'MEDIUM'
          });
        }
      }

      // Check for world-writable files
      const dangerousFiles = this.findWorldWritableFiles(process.cwd());
      issues.push(...dangerousFiles);

      return {
        totalIssues: issues.length,
        issues,
        bananaPermissionScore: issues.length === 0 ? 100 : Math.max(0, 100 - (issues.length * 10))
      };

    } catch (error) {
      logger.error('File permission scan failed', { error: error.message });
      return { error: error.message, issues: [] };
    }
  }

  // Find world-writable files
  findWorldWritableFiles(dir) {
    const issues = [];
    
    try {
      const files = fs.readdirSync(dir);
      
      for (const file of files) {
        if (file === 'node_modules' || file === '.git') continue;
        
        const filePath = path.join(dir, file);
        const stat = fs.statSync(filePath);
        const mode = stat.mode & parseInt('777', 8);
        
        // Check if world-writable (002 bit set)
        if (mode & parseInt('002', 8)) {
          issues.push({
            type: 'world_writable',
            severity: 'HIGH',
            description: `File is world-writable: ${file}`,
            file: file,
            permissions: mode.toString(8),
            bananaRisk: 'HIGH'
          });
        }
      }
    } catch (error) {
      // Ignore permission errors
    }

    return issues;
  }

  // Scan environment security
  async scanEnvironmentSecurity() {
    const issues = [];

    try {
      // Check NODE_ENV
      if (!process.env.NODE_ENV || process.env.NODE_ENV === 'development') {
        issues.push({
          type: 'development_mode',
          severity: 'MEDIUM',
          description: 'Application may be running in development mode',
          bananaRisk: 'MEDIUM'
        });
      }

      // Check for debug mode
      if (process.env.DEBUG || process.env.NODE_DEBUG) {
        issues.push({
          type: 'debug_enabled',
          severity: 'LOW',
          description: 'Debug mode appears to be enabled',
          bananaRisk: 'LOW'
        });
      }

      // Check SSL configuration
      if (!process.env.SSL_CERT_PATH || !process.env.SSL_KEY_PATH) {
        issues.push({
          type: 'no_ssl_config',
          severity: 'MEDIUM',
          description: 'SSL/TLS not configured',
          bananaRisk: 'MEDIUM'
        });
      }

      return {
        totalIssues: issues.length,
        issues,
        bananaEnvironmentScore: this.calculateEnvironmentScore(issues)
      };

    } catch (error) {
      logger.error('Environment security scan failed', { error: error.message });
      return { error: error.message, issues: [] };
    }
  }

  // Scan network configuration
  async scanNetworkConfiguration() {
    const issues = [];

    try {
      // Check if running on default port
      const port = process.env.PORT || 3000;
      if (port == 3000) {
        issues.push({
          type: 'default_port',
          severity: 'LOW',
          description: 'Application running on default port 3000',
          bananaRisk: 'LOW'
        });
      }

      // Check CORS configuration
      if (!process.env.CORS_ORIGINS) {
        issues.push({
          type: 'cors_not_configured',
          severity: 'MEDIUM',
          description: 'CORS origins not explicitly configured',
          bananaRisk: 'MEDIUM'
        });
      }

      return {
        totalIssues: issues.length,
        issues,
        bananaNetworkScore: this.calculateNetworkScore(issues)
      };

    } catch (error) {
      logger.error('Network configuration scan failed', { error: error.message });
      return { error: error.message, issues: [] };
    }
  }

  // Group vulnerabilities by type
  groupVulnerabilitiesByType(vulnerabilities) {
    const grouped = {};
    vulnerabilities.forEach(vuln => {
      if (!grouped[vuln.type]) {
        grouped[vuln.type] = [];
      }
      grouped[vuln.type].push(vuln);
    });
    return grouped;
  }

  // Group vulnerabilities by severity
  groupVulnerabilitiesBySeverity(vulnerabilities) {
    const grouped = { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0 };
    vulnerabilities.forEach(vuln => {
      if (grouped.hasOwnProperty(vuln.severity)) {
        grouped[vuln.severity]++;
      }
    });
    return grouped;
  }

  // Generate scan summary
  generateScanSummary(results) {
    let total = 0;
    let critical = 0;
    let high = 0;
    let medium = 0;
    let low = 0;

    Object.values(results).forEach(result => {
      if (result.vulnerabilities) {
        result.vulnerabilities.forEach(vuln => {
          total++;
          switch (vuln.severity) {
            case 'CRITICAL': critical++; break;
            case 'HIGH': high++; break;
            case 'MEDIUM': medium++; break;
            case 'LOW': low++; break;
          }
        });
      }
      if (result.issues) {
        result.issues.forEach(issue => {
          total++;
          switch (issue.severity) {
            case 'CRITICAL': critical++; break;
            case 'HIGH': high++; break;
            case 'MEDIUM': medium++; break;
            case 'LOW': low++; break;
          }
        });
      }
    });

    return { total, critical, high, medium, low };
  }

  // Calculate banana security score
  calculateBananaSecurityScore(results) {
    let score = 100;
    const summary = this.generateScanSummary(results);

    // Deduct points based on severity
    score -= summary.critical * 20;
    score -= summary.high * 10;
    score -= summary.medium * 5;
    score -= summary.low * 1;

    return Math.max(0, score);
  }

  // Calculate various component scores
  calculateConfigScore(issues) {
    return Math.max(0, 100 - (issues.length * 10));
  }

  calculateEnvironmentScore(issues) {
    return Math.max(0, 100 - (issues.length * 15));
  }

  calculateNetworkScore(issues) {
    return Math.max(0, 100 - (issues.length * 10));
  }

  // Calculate banana risk level
  calculateBananaRisk(severity) {
    const riskMap = {
      'CRITICAL': 'MAXIMUM',
      'HIGH': 'HIGH',
      'MEDIUM': 'MEDIUM',
      'LOW': 'LOW'
    };
    return riskMap[severity] || 'UNKNOWN';
  }

  // Get vulnerability status from npm audit
  getVulnerabilityStatus(metadata) {
    if (!metadata) return 'üçå No data available';
    
    const total = metadata.vulnerabilities?.total || 0;
    if (total === 0) return 'üçå CLEAN BANANA DEPENDENCIES üçå';
    if (total < 5) return 'üü° MINOR BANANA ISSUES üü°';
    if (total < 20) return 'üü† MODERATE BANANA CONCERNS üü†';
    return 'üö® CRITICAL BANANA ALERT üö®';
  }

  // Start periodic scanning
  startPeriodicScanning() {
    // Scan every 6 hours
    setInterval(() => {
      this.performComprehensiveScan().catch(error => {
        logger.error('Periodic scan failed', { error: error.message });
      });
    }, 6 * 60 * 60 * 1000);

    logger.info('üçå PERIODIC BANANA SECURITY SCANNING ENABLED', {
      interval: '6 hours',
      bananaVigilance: 'CONSTANT'
    });
  }

  // Get latest scan results
  getLatestScanResults() {
    if (this.scanHistory.length === 0) {
      return null;
    }

    const latestScanId = this.scanHistory[0].scanId;
    return this.scanResults.get(latestScanId);
  }

  // Get scan history
  getScanHistory() {
    return this.scanHistory;
  }

  // Get vulnerability scanner dashboard
  getBananaVulnerabilityDashboard() {
    const latestScan = this.getLatestScanResults();
    
    return {
      title: 'üçåüîç BANANA VULNERABILITY SCANNER DASHBOARD üîçüçå',
      timestamp: new Date().toISOString(),
      scannerStatus: 'ACTIVE',
      
      currentStatus: {
        lastScanTime: this.lastScanTime ? new Date(this.lastScanTime).toISOString() : null,
        totalScans: this.scanHistory.length,
        bananaSecurityScore: latestScan?.bananaSecurityScore || 'No scans yet',
        overallRisk: this.calculateOverallRisk(latestScan)
      },
      
      latestFindings: latestScan ? {
        critical: latestScan.summary.critical,
        high: latestScan.summary.high,
        medium: latestScan.summary.medium,
        low: latestScan.summary.low,
        total: latestScan.summary.total
      } : null,
      
      scanHistory: this.scanHistory.slice(0, 5), // Last 5 scans
      vulnerabilityTrends: this.getVulnerabilityTrends(),
      recommendations: this.getSecurityRecommendations(latestScan),
      
      bananaStatus: latestScan ? 
        (latestScan.bananaSecurityScore > 80 ? 'üçå SECURE BANANA FORTRESS üçå' : 
         latestScan.bananaSecurityScore > 60 ? 'üü° BANANA NEEDS ATTENTION üü°' : 
         'üö® BANANA IN DANGER üö®') : 'üîç SCANNING FOR BANANA THREATS üîç'
    };
  }

  // Calculate overall risk
  calculateOverallRisk(latestScan) {
    if (!latestScan) return 'UNKNOWN';
    
    const score = latestScan.bananaSecurityScore;
    if (score >= 90) return 'MINIMAL';
    if (score >= 70) return 'LOW';
    if (score >= 50) return 'MEDIUM';
    if (score >= 30) return 'HIGH';
    return 'CRITICAL';
  }

  // Get vulnerability trends
  getVulnerabilityTrends() {
    if (this.scanHistory.length < 2) {
      return { trend: 'INSUFFICIENT_DATA', change: 0 };
    }

    const latest = this.scanHistory[0];
    const previous = this.scanHistory[1];
    
    const latestTotal = latest.criticalIssues + latest.highIssues;
    const previousTotal = previous.criticalIssues + previous.highIssues;
    
    const change = latestTotal - previousTotal;
    let trend = 'STABLE';
    
    if (change > 0) trend = 'INCREASING';
    else if (change < 0) trend = 'DECREASING';
    
    return { trend, change, bananaDirection: this.getBananaTrendDirection(trend) };
  }

  // Get banana trend direction
  getBananaTrendDirection(trend) {
    switch (trend) {
      case 'INCREASING': return 'üìàüçå More banana threats detected';
      case 'DECREASING': return 'üìâüçå Fewer banana threats';
      case 'STABLE': return '‚û°Ô∏èüçå Stable banana security';
      default: return 'üçå Banana trend unknown';
    }
  }

  // Get security recommendations
  getSecurityRecommendations(latestScan) {
    const recommendations = [];
    
    if (!latestScan) {
      recommendations.push({
        priority: 'HIGH',
        action: 'Run initial security scan',
        bananaMessage: 'üçå Start banana security scanning! üçå'
      });
      return recommendations;
    }

    if (latestScan.summary.critical > 0) {
      recommendations.push({
        priority: 'CRITICAL',
        action: `Fix ${latestScan.summary.critical} critical vulnerabilities immediately`,
        bananaMessage: 'üö®üçå Critical banana threats detected! üçåüö®'
      });
    }

    if (latestScan.summary.high > 5) {
      recommendations.push({
        priority: 'HIGH',
        action: `Address ${latestScan.summary.high} high-severity vulnerabilities`,
        bananaMessage: '‚ö†Ô∏èüçå Many high-risk banana threats! üçå‚ö†Ô∏è'
      });
    }

    if (latestScan.bananaSecurityScore < 70) {
      recommendations.push({
        priority: 'MEDIUM',
        action: 'Improve overall security posture',
        bananaMessage: 'üçå Banana security needs strengthening! üçå'
      });
    }

    return recommendations;
  }

  // Force immediate scan
  async forceImmediateScan() {
    logger.info('üçå IMMEDIATE BANANA SECURITY SCAN REQUESTED', {
      requestedAt: new Date().toISOString()
    });
    
    return await this.performComprehensiveScan();
  }
}

module.exports = BananaVulnerabilityScanner;